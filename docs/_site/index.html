<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
<title>SKIDL &vert; SKIDL</title>
<meta name="description" content="Use Python to create circuits.">
<meta name="keywords" content="Python, SKiDL, home">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xesscorp.github.io/skidl/docs/_site/images/logo.png">
<meta name="twitter:title" content="SKiDL">
<meta name="twitter:description" content="Use Python to create circuits.">
<meta name="twitter:creator" content="@xesscorp">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="SKiDL">
<meta property="og:description" content="Use Python to create circuits.">
<meta property="og:url" content="https://xesscorp.github.io/skidl/docs/_site/">
<meta property="og:site_name" content="SKiDL">
<meta property="og:image" content="https://xesscorp.github.io/skidl/docs/_site/images/">

<meta name="google-site-verification" content="https://ssl.bing.com/webmaster/configure/verify/ownership Option 2 content= goes here">



<link rel="canonical" href="https://xesscorp.github.io/skidl/docs/_site/">
<link href="https://xesscorp.github.io/skidl/docs/_site/feed.xml" type="application/atom+xml" rel="alternate" title="SKiDL Feed">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />


    <link href='http://fonts.googleapis.com/css?family=Montserrat:400,700|Open+Sans:400,600,300,800,700' rel='stylesheet' type='text/css'>
	<!-- <link rel="stylesheet" href="https://xesscorp.github.io/skidl/docs/_site/assets/css/vendor/font-awesome.min.css"> -->
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://xesscorp.github.io/skidl/docs/_site/assets/css/vendor/normalize.css">
    <link rel="stylesheet" href="https://xesscorp.github.io/skidl/docs/_site/assets/css/vendor/nprogress.css">
    <link rel="stylesheet" href="https://xesscorp.github.io/skidl/docs/_site/assets/css/vendor/foundation.min.css">
    <link rel="stylesheet" href="https://xesscorp.github.io/skidl/docs/_site/assets/css/style.css">
    <link rel="stylesheet" href="https://xesscorp.github.io/skidl/docs/_site/assets/css/post.css">





<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="https://xesscorp.github.io/skidl/docs/_site/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="https://xesscorp.github.io/skidl/docs/_site/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="https://xesscorp.github.io/skidl/docs/_site/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://xesscorp.github.io/skidl/docs/_site/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://xesscorp.github.io/skidl/docs/_site/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://xesscorp.github.io/skidl/docs/_site/images/apple-touch-icon-144x144-precomposed.png">

    </head>
    <body class="home-template" itemscope itemtype="http://schema.org/WebPage">

        <header class="notepad-site-head">
            <div class="notepad-site-head-menu">
                <a class="notepad-blog-logo" href="https://xesscorp.github.io/skidl/docs/_site"><img src="https://xesscorp.github.io/skidl/docs/_site/images/logo.png" alt="Site Logo" /></a>
                <div class="notepad-blog-menu">
                    <div class="notepad-mobile-menu show-for-small">
                        <a href="#"><i class="fa fa-bars"></i></a>
                    </div>
                    <ul class="notepad-menu">
                        <li class="notepad-mobile-close-btn show-for-small text-right">
                            <a href="#"><i class="fa fa-times"></i></a>
                        </li>
                        
                        <li>
                            <a href="https://xesscorp.github.io/skidl/docs/_site/">Home</a>
                             
                        </li>
                        
                        <li>
                            <a href="https://xesscorp.github.io/skidl/docs/_site/blog">Blog</a>
                             
                        </li>
                        
                        <li>
                            <a href="https://xesscorp.github.io/skidl/docs/_site/api.html">API</a>
                             
                        </li>
                        
                        <li>
                            <a href="http://github.com/xesscorp/skidl">Github</a>
                             
                        </li>
                        
                        <li>
                            <a href="https://xesscorp.github.io/skidl/docs/_site/about">About</a>
                             
                        </li>
                                    
                        <li><a href="https://xesscorp.github.io/skidl/docs/_site/feed.xml" title="Atom/RSS feed"><i class="icon-rss"></i> Feed</a></li>
                    </ul>
                </div>
                <div class="clearfix"></div>
            </div>
            <div class="notepad-site-head-content" >
                <div class="notepad-site-head-bg"></div>
                <h1 class="notepad-blog-title">
                    <span class="notepad-site-head-title-bg">
                    SKiDL
                    </span>
                </h1>
                <h2 class="notepad-blog-description">Python &rarr; Circuits</h2>
            </div>
        </header>

        <main class="notepad-content" role="main">
            <!-- <article class="notepad-index-post post row" role="main"> -->
            <article class="post row" role="main">
                <div class="small-12 medium-9 large-10 columns">
                    <h1 id="tldr">TL;DR</h1>

<p><strong>Never use a lousy schematic editor again!</strong>
SKiDL is a simple module that lets you describe electronic circuits using Python.
The resulting Python program outputs a netlist that a PCB layout tool uses to
create a finished circuit board.</p>

<h3 id="contents">Contents</h3>

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#installation">Installation</a></li>
  <li><a href="#basic-usage">Basic Usage</a></li>
  <li><a href="#going-deeper">Going Deeper</a></li>
  <li><a href="#going-really-deep">Going Really Deep</a></li>
  <li><a href="#converting-existing-designs-to-skidl">Converting Existing Designs to SKiDL</a></li>
  <li><a href="#spice-simulations">SPICE Simulations</a></li>
</ul>

<h1 id="introduction">Introduction</h1>

<p>SKiDL is a module that allows you to compactly describe the interconnection of 
electronic circuits and components using Python.
The resulting Python program performs electrical rules checking
for common mistakes and outputs a netlist that serves as input to
a PCB layout tool.</p>

<h2 id="features">Features</h2>

<ul>
  <li>Has a powerful, flexible syntax (because it <em>is</em> Python).</li>
  <li>Permits compact descriptions of electronic circuits (think about <em>not</em> tracing
signals through a multi-page schematic).</li>
  <li>Allows textual descriptions of electronic circuits (think about using 
<code class="highlighter-rouge">diff</code> and <a href="https://en.wikipedia.org/wiki/Git">git</a> for circuits).</li>
  <li>Performs electrical rules checking (ERC) for common mistakes (e.g., unconnected device I/O pins).</li>
  <li>Supports linear / hierarchical / mixed descriptions of electronic designs.</li>
  <li>Fosters design reuse (think about using <a href="pypi.org">PyPi</a> and <a href="github.com">Github</a>
to distribute electronic designs).</li>
  <li>Makes possible the creation of <em>smart circuit modules</em> whose behavior / structure are changed parametrically
(think about filters whose component values are automatically adjusted based on your
desired cutoff frequency).</li>
  <li>Can work with any ECAD tool (only two methods are needed: one for reading the part libraries and another
for outputing the correct netlist format).</li>
  <li>Takes advantage of all the benefits of the Python ecosystem (because it <em>is</em> Python).</li>
  <li>Free software: MIT license.</li>
  <li>Open source: <a href="https://github.com/xesscorp/skidl">https://github.com/xesscorp/skidl</a></li>
</ul>

<p>As a very simple example, the SKiDL program below describes a circuit that
takes an input voltage, divides it by three, and outputs it:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">skidl</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c"># Create input &amp; output voltages and ground reference.</span>
<span class="n">vin</span><span class="p">,</span> <span class="n">vout</span><span class="p">,</span> <span class="n">gnd</span> <span class="o">=</span> <span class="n">Net</span><span class="p">(</span><span class="s">'VI'</span><span class="p">),</span> <span class="n">Net</span><span class="p">(</span><span class="s">'VO'</span><span class="p">),</span> <span class="n">Net</span><span class="p">(</span><span class="s">'GND'</span><span class="p">)</span>

<span class="c"># Create two resistors.</span>
<span class="n">r1</span><span class="p">,</span> <span class="n">r2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Part</span><span class="p">(</span><span class="s">'device'</span><span class="p">,</span> <span class="s">'R'</span><span class="p">,</span> <span class="n">TEMPLATE</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="s">'Resistor_SMD.pretty:R_0805_2012Metric'</span><span class="p">)</span>
<span class="n">r1</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s">'1K'</span>   <span class="c"># Set upper resistor value.</span>
<span class="n">r2</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s">'500'</span>  <span class="c"># Set lower resistor value.</span>

<span class="c"># Connect the nets and resistors.</span>
<span class="n">vin</span> <span class="o">+=</span> <span class="n">r1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>      <span class="c"># Connect the input to the upper resistor.</span>
<span class="n">gnd</span> <span class="o">+=</span> <span class="n">r2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>      <span class="c"># Connect the lower resistor to ground.</span>
<span class="n">vout</span> <span class="o">+=</span> <span class="n">r1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">r2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c"># Output comes from the connection of the two resistors.</span>

<span class="n">generate_netlist</span><span class="p">()</span>
</code></pre>
</div>

<p>And this is the netlist output that can be fed to a program like KiCad’s <code class="highlighter-rouge">PCBNEW</code> to
create the physical PCB:</p>

<div class="language-text highlighter-rouge"><pre class="highlight"><code>(export (version D)                                                                                    
  (design                                                                                              
    (source "C:\xesscorp\KiCad\tools\skidl\tests\vdiv.py")                                             
    (date "09/14/2018 08:49 PM")                                                                       
    (tool "SKiDL (0.0.23)"))                                                                           
  (components                                                                                          
    (comp (ref R1)                                                                                     
      (value 1K)                                                                                       
      (footprint Resistor_SMD.pretty:R_0805_2012Metric)                                                                 
      (fields                                                                                          
        (field (name description) Resistor)                                                            
        (field (name keywords) "r res resistor"))                                                      
      (libsource (lib device) (part R))                                                                
      (sheetpath (names /top/12995167876889795071) (tstamps /top/12995167876889795071)))               
    (comp (ref R2)                                                                                     
      (value 500)                                                                                      
      (footprint Resistor_SMD.pretty:R_0805_2012Metric)                                                                 
      (fields                                                                                          
        (field (name description) Resistor)                                                            
        (field (name keywords) "r res resistor"))                                                      
      (libsource (lib device) (part R))                                                                
      (sheetpath (names /top/8869138953290924483) (tstamps /top/8869138953290924483))))                
  (nets                                                                                                
    (net (code 0) (name GND)                                                                           
      (node (ref R2) (pin 2)))                                                                         
    (net (code 1) (name VI)                                                                            
      (node (ref R1) (pin 1)))                                                                         
    (net (code 2) (name VO)                                                                            
      (node (ref R1) (pin 2))                                                                          
      (node (ref R2) (pin 1))))                                                                        
)                                                                                                      
</code></pre>
</div>

<h1 id="installation">Installation</h1>

<p>SKiDL is pure Python so it’s easy to install:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>pip install skidl
</code></pre>
</div>

<p>To give SKiDL some part libraries to work with,
you’ll also need to install <a href="http://kicad-pcb.org/">KiCad</a>.
Then, you’ll need to set an environment variable so SKiDL can find the libraries.
For Windows, do this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>set KICAD_SYMBOL_DIR=C:\Program Files\KiCad\share\kicad\kicad-symbols
</code></pre>
</div>

<p>And for linux-type OSes, define the environment variable in your <code class="highlighter-rouge">.bashrc</code> like so:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>export KICAD_SYMBOL_DIR="/Library/Application Support/kicad/kicad-symbols"
</code></pre>
</div>

<p><strong>These paths are OS-dependent</strong>, so launch KiCAD and click <code class="highlighter-rouge">Preferences-&gt;Configure Paths</code>
to reveal the needed paths.</p>

<h1 id="basic-usage">Basic Usage</h1>

<p>This is the minimum that you need to know to design electronic circuitry
using SKiDL:</p>

<ul>
  <li>How to get access to SKiDL.</li>
  <li>How to find and instantiate a component (or <em>part</em>).</li>
  <li>How to connect <em>pins</em> of the parts to each other using <em>nets</em>.</li>
  <li>How to run an ERC on the circuit.</li>
  <li>How to generate a <em>netlist</em> for the circuit that serves as input to a PCB layout tool.</li>
</ul>

<p>I’ll demonstrate these steps using SKiDL in an interactive Python session,
but normally the statements that are shown would be entered into a file and
executed as a Python script.</p>

<h2 id="accessing-skidl">Accessing SKiDL</h2>

<p>To use skidl in a project, just place the following at the top of your file:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">skidl</span>
</code></pre>
</div>

<p>But for this tutorial, I’ll just import everything:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">skidl</span> <span class="kn">import</span> <span class="o">*</span>
</code></pre>
</div>

<h2 id="finding-parts">Finding Parts</h2>

<p>SKiDL provides a convenience function for searching for parts called
(naturally) <code class="highlighter-rouge">search</code>.
For example, if you needed an operational amplifier, then the following command would
pull up some likely candidates:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; search('opamp')
linear.lib: LT1492
linear.lib: MCP601SN (2.7V to 6.0V Single Supply CMOS Operational Amplifier, SO-8)
linear.lib: LM321 (Low Power Single Operational Amplifier)
linear.lib: MCP601R (2.7V to 6.0V Single Supply CMOS Operational Amplifier, SOT-23-5)
linear.lib: LM555N (Dual Op amp, rail-to-rail, 8MHz, MSOP8, SOIC8)
...
linear.lib: MCP603ST (2.7V to 6.0V Single Supply CMOS Operational Amplifier, with Chip Select, TSSOP-8)
linear.lib: NE5534 (Low-Noise High-Speed Audio Operational Amplifier)
linear.lib: LT1493
linear.lib: MCP601P (2.7V to 6.0V Single Supply CMOS Operational Amplifier, DIP-8)
linear.lib: MCP601ST (2.7V to 6.0V Single Supply CMOS Operational Amplifier, TSSOP-8)
</code></pre>
</div>

<p><code class="highlighter-rouge">search</code> accepts a regular expression and scans for it <em>anywhere</em> within the
name, description and keywords of all the parts in the library path.
(You can read more about how SKiDL handles libraries <a href="#libraries">here</a>.)
So the following search pulls up several candidates:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; search('lm35')
dc-dc.lib: LM3578 (Switching Regulator (adjustable))
linear.lib: LM358 (Dual Rail-to-rail CMOS Operational Amplifier)
regul.lib: LM350T (3A 33V Adjustable Linear Regulator, TO-220)
sensors.lib: LM35-LP (Precision centigrade temperature sensor, TO-92 package)
sensors.lib: LM35-D (Precision centigrade temperature sensor, SOIC-8 package)
sensors.lib: LM35-NEB (Precision centigrade temperature sensor, TO-220 package)
</code></pre>
</div>

<p>If you want to restrict the search to a specific part, then
use a regular expression like the following:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; search('^lm358$')
linear.lib: LM358 (Dual Rail-to-rail CMOS Operational Amplifier)
</code></pre>
</div>

<p>Once you have the part name and library, you can see the part’s pin numbers, names
and their functions using the <code class="highlighter-rouge">show</code> function:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; show('linear', 'lm358')

LM358: Dual Rail-to-rail CMOS Operational Amplifier
    Pin None/4/V-/POWER-IN
    Pin None/8/V+/POWER-IN
    Pin None/1/~/OUTPUT
    Pin None/2/-/INPUT
    Pin None/3/+/INPUT
    Pin None/5/+/INPUT
    Pin None/6/-/INPUT
    Pin None/7/~/OUTPUT
</code></pre>
</div>

<p><code class="highlighter-rouge">show</code> looks for exact matches of the part name in a library, so the following
command raises an error:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; show('linear', 'lm35')
ERROR: Unable to find part lm35 in library linear.
</code></pre>
</div>

<h2 id="instantiating-parts">Instantiating Parts</h2>

<p>The part library and name are used to instantiate a part as follows:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; resistor = Part('device','R')
</code></pre>
</div>

<p>You can customize the resistor by setting its attributes:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; resistor.value = '1K' 
&gt;&gt;&gt; resistor.value        
'1K'                      
</code></pre>
</div>

<p>You can also combine the setting of attributes with the creation of the part:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; resistor = Part('device', 'R', value='1K')
&gt;&gt;&gt; resistor.value
'1K'
</code></pre>
</div>

<p>You can use any valid Python name for a part attribute, but <code class="highlighter-rouge">ref</code>, <code class="highlighter-rouge">value</code>,
and <code class="highlighter-rouge">footprint</code> are necessary in order to generate the final netlist
for your circuit. And the attribute can hold any type of Python object,
but simple strings are probably the most useful.</p>

<p>The <code class="highlighter-rouge">ref</code> attribute holds the <em>reference</em> for the part. It’s set automatically
when you create the part:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; resistor.ref
'R1'
</code></pre>
</div>

<p>Since this was the first resistor we created, it has the honor of being named <code class="highlighter-rouge">R1</code>.
But you can easily change it:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; resistor.ref = 'R5'
&gt;&gt;&gt; resistor.ref
'R5'
</code></pre>
</div>

<p>Now what happens if we create another resistor?:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; another_res = Part('device','R')   
&gt;&gt;&gt; another_res.ref                        
'R1'
</code></pre>
</div>

<p>Since the <code class="highlighter-rouge">R1</code> reference was now available, the new resistor got it.
What if we tried renaming the first resistor back to <code class="highlighter-rouge">R1</code>:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; resistor.ref = 'R1'
&gt;&gt;&gt; resistor.ref
'R1_1'
</code></pre>
</div>

<p>Since the <code class="highlighter-rouge">R1</code> reference was already taken, SKiDL tried to give us
something close to what we wanted.
SKiDL won’t let different parts have the same reference because
that would confuse the hell out of everybody.</p>

<h2 id="connecting-pins">Connecting Pins</h2>

<p>Parts are great and all, but not very useful if they aren’t connected to anything.
The connections between parts are called <em>nets</em> (think of them as wires)
and every net has one or more part <em>pins</em> on it.
SKiDL makes it easy to create nets and connect pins to them. 
To demonstrate, let’s build the voltage divider circuit
shown in the introduction.</p>

<p>First, start by creating two resistors (note that I’ve also added the
<code class="highlighter-rouge">footprint</code> attribute that describes the physical package for the resistors):</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">rup</span> <span class="o">=</span> <span class="n">Part</span><span class="p">(</span><span class="s">'device'</span><span class="p">,</span> <span class="s">'R'</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s">'1K'</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="s">'Resistor_SMD.pretty:R_0805_2012Metric'</span><span class="p">)</span>                            
<span class="o">&gt;&gt;&gt;</span> <span class="n">rlow</span> <span class="o">=</span> <span class="n">Part</span><span class="p">(</span><span class="s">'device'</span><span class="p">,</span> <span class="s">'R'</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s">'500'</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="s">'Resistor_SMD.pretty:R_0805_2012Metric'</span><span class="p">)</span>                          
<span class="o">&gt;&gt;&gt;</span> <span class="n">rup</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span> <span class="n">rlow</span><span class="o">.</span><span class="n">ref</span>                                                
<span class="p">(</span><span class="s">'R1'</span><span class="p">,</span> <span class="s">'R2'</span><span class="p">)</span>                                                         
<span class="o">&gt;&gt;&gt;</span> <span class="n">rup</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">rlow</span><span class="o">.</span><span class="n">value</span>                                            
<span class="p">(</span><span class="s">'1K'</span><span class="p">,</span> <span class="s">'500'</span><span class="p">)</span>     
</code></pre>
</div>

<p>To bring the voltage that will be divided into the circuit, let’s create a net:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; v_in = Net('VIN')
&gt;&gt;&gt; v_in.name
'VIN'
</code></pre>
</div>

<p>Now attach the net to one of the pins of the <code class="highlighter-rouge">rup</code> resistor
(resistors are bidirectional which means it doesn’t matter which pin, so pick pin 1):</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; rup[1] += v_in
</code></pre>
</div>

<p>You can verify that the net is attached to pin 1 of the resistor like this:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; rup[1].net
VIN: Pin R1/1/~/PASSIVE
</code></pre>
</div>

<p>Next, create a ground reference net and attach it to <code class="highlighter-rouge">rlow</code>:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; gnd = Net('GND')
&gt;&gt;&gt; rlow[1] += gnd
&gt;&gt;&gt; rlow[1].net
GND: Pin R2/1/~/PASSIVE
</code></pre>
</div>

<p>Finally, the divided voltage has to come out of the circuit on a net.
This can be done in several ways.
The first way is to define the output net and then attach the unconnected
pins of both resistors to it:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; v_out = Net('VO')
&gt;&gt;&gt; v_out += rup[2], rlow[2]
&gt;&gt;&gt; rup[2].net, rlow[2].net
(VO: Pin R1/2/~/PASSIVE, Pin R2/2/~/PASSIVE, VO: Pin R1/2/~/PASSIVE, Pin R2/2/~/PASSIVE)
</code></pre>
</div>

<p>An alternate method is to connect the resistors and then attach their
junction to the output net:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; rup[2] += rlow[2]
&gt;&gt;&gt; v_out = Net('VO')
&gt;&gt;&gt; v_out += rlow[2]
&gt;&gt;&gt; rup[2].net, rlow[2].net
(VO: Pin R1/2/~/PASSIVE, Pin R2/2/~/PASSIVE, VO: Pin R1/2/~/PASSIVE, Pin R2/2/~/PASSIVE)
</code></pre>
</div>

<p>Either way works! Sometimes pin-to-pin connections are easier when you’re
just wiring two devices together, while the pin-to-net connection method
excels when three or more pins have a common connection.</p>

<h2 id="checking-for-errors">Checking for Errors</h2>

<p>Once the parts are wired together, you can do simple electrical rules checking
like this:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; ERC()                           
                                    
2 warnings found during ERC.        
0 errors found during ERC.          
</code></pre>
</div>

<p>Since this is an interactive session, the ERC warnings and errors are stored 
in the file <code class="highlighter-rouge">skidl.erc</code>. (Normally, your SKiDL circuit description is stored
as a Python script such as <code class="highlighter-rouge">my_circuit.py</code> and the <code class="highlighter-rouge">ERC()</code> function will
dump its messages to <code class="highlighter-rouge">my_circuit.erc</code>.)
The ERC messages are:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>WARNING: Only one pin (PASSIVE pin 1/~ of R/R1) attached to net VIN.
WARNING: Only one pin (PASSIVE pin 1/~ of R/R2) attached to net GND.
</code></pre>
</div>

<p>These messages are generated because the <code class="highlighter-rouge">VIN</code> and <code class="highlighter-rouge">GND</code> nets each have only
a single pin on them and this usually indicates a problem.
But it’s OK for this simple example, so the ERC can be turned off for
these two nets to prevent the spurious messages:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; v_in.do_erc = False
&gt;&gt;&gt; gnd.do_erc = False
&gt;&gt;&gt; ERC()

No ERC errors or warnings found.
</code></pre>
</div>

<h2 id="generating-a-netlist">Generating a Netlist</h2>

<p>The end goal of using SKiDL is to generate a netlist that can be used
with a layout tool to generate a PCB. The netlist is output as follows:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; generate_netlist()
</code></pre>
</div>

<p>Like the ERC output, the netlist shown below is stored in the file <code class="highlighter-rouge">skidl.net</code>.
But if your SKiDL circuit description is in the <code class="highlighter-rouge">my_circuit.py</code> file, 
then the netlist will be stored in <code class="highlighter-rouge">my_circuit.net</code>.</p>

<div class="language-text highlighter-rouge"><pre class="highlight"><code>(export (version D)
  (design
    (source "C:\xesscorp\KiCad\tools\skidl\skidl\skidl.py")
    (date "08/12/2016 10:05 PM")
    (tool "SKiDL (0.0.1)"))
  (components
    (comp (ref R1)
      (value 1K)
      (footprint Resistor_SMD.pretty:R_0805_2012Metric))
    (comp (ref R2)
      (value 500)
      (footprint Resistor_SMD.pretty:R_0805_2012Metric)))
  (nets
    (net (code 0) (name "VIN")
      (node (ref R1) (pin 1)))
    (net (code 1) (name "GND")
      (node (ref R2) (pin 1)))
    (net (code 2) (name "VO")
      (node (ref R1) (pin 2))
      (node (ref R2) (pin 2))))
)
(export (version D)
  (design
    (source "C:\TEMP\skidl tests\intro_example.py")
    (date "04/19/2017 04:09 PM")
    (tool "SKiDL (0.0.12)"))
  (components
    (comp (ref R1)
      (value 1K)
      (footprint Resistor_SMD.pretty:R_0805_2012Metric)
      (fields
        (field (name keywords) "r res resistor")
        (field (name description) Resistor))
      (libsource (lib device) (part R)))
    (comp (ref R2)
      (value 500)
      (footprint Resistor_SMD.pretty:R_0805_2012Metric)
      (fields
        (field (name keywords) "r res resistor")
        (field (name description) Resistor))
      (libsource (lib device) (part R))))
  (nets
    (net (code 0) (name GND)
      (node (ref R2) (pin 2)))
    (net (code 1) (name VI)
      (node (ref R1) (pin 1)))
    (net (code 2) (name VO)
      (node (ref R1) (pin 2))
      (node (ref R2) (pin 1))))
)

</code></pre>
</div>

<p>You can also generate the netlist in XML format:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; generate_xml()
</code></pre>
</div>

<p>This is useful in a KiCad environment where the XML file is used as the
input to BOM-generation tools.</p>

<h1 id="going-deeper">Going Deeper</h1>

<p>The previous section showed the bare minimum you need to know to design
circuits with SKiDL, but doing a complicated circuit that way would suck donkeys.
This section will talk about some more advanced features.</p>

<h2 id="basic-skidl-objects-parts-pins-nets-buses">Basic SKiDL Objects: Parts, Pins, Nets, Buses</h2>

<p>SKiDL uses four types of objects to represent a circuit: <code class="highlighter-rouge">Part</code>, <code class="highlighter-rouge">Pin</code>,
<code class="highlighter-rouge">Net</code>, and <code class="highlighter-rouge">Bus</code>.</p>

<p>The <code class="highlighter-rouge">Part</code> object represents an electronic component, which SKiDL thinks of as simple
bags of <code class="highlighter-rouge">Pin</code> objects with a few other attributes attached 
(like the part number, name, reference, value, footprint, etc.).</p>

<p>The <code class="highlighter-rouge">Pin</code> object represents a terminal that brings an electronic signal into
and out of the part. Each <code class="highlighter-rouge">Pin</code> object has two important attributes:</p>

<ul>
  <li><code class="highlighter-rouge">part</code> which stores the reference to the <code class="highlighter-rouge">Part</code> object to which the pin belongs.</li>
  <li><code class="highlighter-rouge">net</code> which stores the the reference to the <code class="highlighter-rouge">Net</code> object that the pin is
connected to, or <code class="highlighter-rouge">None</code> if the pin is unconnected.</li>
</ul>

<p>A <code class="highlighter-rouge">Net</code> object is kind of like a <code class="highlighter-rouge">Part</code>: it’s a simple bag of pins.
The difference is, unlike a part, pins can be added to a net.
This happens when a pin on some part is connected to the net or when the 
net is merged with another net.</p>

<p>Finally, a <code class="highlighter-rouge">Bus</code> is just a list of <code class="highlighter-rouge">Net</code> objects.
A bus of a certain width can be created from a number of existing nets,
newly-created nets, or both.</p>

<h2 id="creating-skidl-objects">Creating SKiDL Objects</h2>

<p>Here’s the most common way to create a part in your circuit:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">my_part</span> <span class="o">=</span> <span class="n">Part</span><span class="p">(</span><span class="s">'some_library'</span><span class="p">,</span> <span class="s">'some_part_name'</span><span class="p">)</span>
</code></pre>
</div>

<p>When this is processed, the current directory will be checked for a file
called <code class="highlighter-rouge">some_library.lib</code> which will be opened and scanned for a part with the
name <code class="highlighter-rouge">some_part_name</code>. If the file is not found or it doesn’t contain
the requested part, then the process will be repeated using KiCad’s default
library directory.
(You can change SKiDL’s library search by changing the list of directories
stored in the <code class="highlighter-rouge">skidl.lib_search_paths_kicad</code> list.)</p>

<p>You’re not restricted to using only the current directory or the KiCad default
directory to search for parts. You can also search any file for a part by 
using a full file name:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">my_part</span> <span class="o">=</span> <span class="n">Part</span><span class="p">(</span><span class="s">'C:/my_libs/my_great_parts.lib'</span><span class="p">,</span> <span class="s">'my_super_regulator'</span><span class="p">)</span>
</code></pre>
</div>

<p>You’re also not restricted to getting an exact match on the part name: you can
use a <em>regular expression</em> instead. For example, this will find a part
with “358” anywhere in a part name or alias:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">my_part</span> <span class="o">=</span> <span class="n">Part</span><span class="p">(</span><span class="s">'some_library'</span><span class="p">,</span> <span class="s">'.*358.*'</span><span class="p">)</span>
</code></pre>
</div>

<p>If the regular expression matches more than one part, then you’ll only get the
first match and a warning that multiple parts were found.</p>

<p>Once you have a part, you can set its attributes like you could for any Python
object. As was shown previously, the <code class="highlighter-rouge">ref</code> attribute will already be set
but you can override it:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">my_part</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="s">'U5'</span>
</code></pre>
</div>

<p>In addition, the <code class="highlighter-rouge">value</code> and <code class="highlighter-rouge">footprint</code> attributes are required for generating
a netlist. You can also add any other attribute:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">my_part</span><span class="o">.</span><span class="n">manf</span> <span class="o">=</span> <span class="s">'Atmel'</span>
<span class="n">my_part</span><span class="o">.</span><span class="nb">setattr</span><span class="p">(</span><span class="s">'manf#'</span><span class="p">,</span> <span class="s">'ATTINY4-TSHR'</span>
</code></pre>
</div>

<p>It’s also possible to set the attributes during the part creation:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">my_part</span> <span class="o">=</span> <span class="n">Part</span><span class="p">(</span><span class="s">'some_lib'</span><span class="p">,</span> <span class="s">'some_part'</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="s">'U5'</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="s">'Package_TO_SOT_SMD.pretty:SOT-23-6'</span><span class="p">,</span> <span class="n">manf</span><span class="o">=</span><span class="s">'Atmel'</span><span class="p">)</span>
</code></pre>
</div>

<p>Creating nets is also simple:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">my_net</span> <span class="o">=</span> <span class="n">Net</span><span class="p">()</span>              <span class="c"># An unnamed net.</span>
<span class="n">my_other_net</span> <span class="o">=</span> <span class="n">Net</span><span class="p">(</span><span class="s">'Fred'</span><span class="p">)</span>  <span class="c"># A named net.</span>
</code></pre>
</div>

<p>As with parts, SKiDL will alter the name you assign to a net if it collides with another net
having the same name.</p>

<p>You can create a bus of a certain width like this:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">my_bus</span> <span class="o">=</span> <span class="n">Bus</span><span class="p">(</span><span class="s">'bus_name'</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>  <span class="c"># Create a byte-wide bus.</span>
</code></pre>
</div>

<p>(All buses must be named, but SKiDL will look for and correct colliding
bus names.)</p>

<p>You can also create a bus from existing nets, or buses, or the pins of parts:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">my_part</span> <span class="o">=</span> <span class="n">Part</span><span class="p">(</span><span class="s">'linear'</span><span class="p">,</span> <span class="s">'LM358'</span><span class="p">)</span>
<span class="n">a_net</span> <span class="o">=</span> <span class="n">Net</span><span class="p">()</span>
<span class="n">b_net</span> <span class="o">=</span> <span class="n">Net</span><span class="p">()</span>
<span class="n">bus_nets</span> <span class="o">=</span> <span class="n">Bus</span><span class="p">(</span><span class="s">'net_bus'</span><span class="p">,</span> <span class="n">a_net</span><span class="p">,</span> <span class="n">b_net</span><span class="p">)</span>            <span class="c"># A 2-bit bus.</span>
<span class="n">bus_pins</span> <span class="o">=</span> <span class="n">Bus</span><span class="p">(</span><span class="s">'pin_bus'</span><span class="p">,</span> <span class="n">my_part</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">my_part</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>  <span class="c"># A 2-bit bus.</span>
<span class="n">bus_buses</span> <span class="o">=</span> <span class="n">Bus</span><span class="p">(</span><span class="s">'bus_bus'</span><span class="p">,</span> <span class="n">my_bus</span><span class="p">)</span>                 <span class="c"># An 8-bit bus.</span>
</code></pre>
</div>

<p>Finally, you can mix-and-match any combination of widths, nets, buses or part pins:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">bus_mixed</span> <span class="o">=</span> <span class="n">Bus</span><span class="p">(</span><span class="s">'mongrel'</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">a_net</span><span class="p">,</span> <span class="n">my_bus</span><span class="p">,</span> <span class="n">my_part</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>  <span class="c"># 8+1+8+1 = 18-bit bus.</span>
</code></pre>
</div>

<p>Finally, you can modify an existing bus by inserting or extending it with any combination
of widths, nets, buses or pins:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">bus</span> <span class="o">=</span> <span class="n">Bus</span><span class="p">(</span><span class="s">'A'</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>   <span class="c"># Eight-bit bus.</span>
<span class="n">bus</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Bus</span><span class="p">(</span><span class="s">'I'</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  <span class="c"># Insert 3-bit bus before bus line bus[4].</span>
<span class="n">bus</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">Pin</span><span class="p">(),</span> <span class="n">Net</span><span class="p">())</span> <span class="c"># Extend bus with another 5-bit bus, a pin, and a net.</span>
</code></pre>
</div>

<p>The final object you can create is a <code class="highlighter-rouge">Pin</code>. You’ll probably never do this
(except in interactive sessions), and it’s probably a mistake if
you ever do do it, but here’s how to do it:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; p = Pin(num=1, name='my_pin', func=Pin.TRISTATE)
&gt;&gt;&gt; p
Pin ???/1/my_pin/TRISTATE
</code></pre>
</div>

<h2 id="finding-skidl-objects">Finding SKiDL Objects</h2>

<p>Sometimes you may want to access a bus or net that’s already been created.
In such an instance, you can use the <code class="highlighter-rouge">get()</code> class method:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="n">Net</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'Fred'</span><span class="p">)</span>  <span class="c"># Find the existing Net object named 'Fred'.</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Bus</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'A'</span><span class="p">)</span>     <span class="c"># Find the existing Bus object named 'A'.</span>
</code></pre>
</div>

<p>If a net or bus is found with the exact name that was given, then that SKiDL
object is returned (no wild-card searches using regular expressions are allowed).
If the search is unsuccessful, <code class="highlighter-rouge">None</code> is returned.</p>

<p>There may be other times when you want to access a particular bus or net and,
if it doesn’t exist, then create it.
The <code class="highlighter-rouge">fetch()</code> class method is used for this:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="n">Net</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="s">'Fred'</span><span class="p">)</span>  <span class="c"># Find the existing Net object named 'Fred' or create it if not found.</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Bus</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="s">'A'</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>   <span class="c"># Find the existing Bus object named 'A' or create it if not found.</span>
</code></pre>
</div>

<p>Note that with the <code class="highlighter-rouge">Bus.fetch()</code> method, you also have to provide the arguments to
build the bus (such as its width) in case it doesn’t exist.</p>

<h2 id="copying-skidl-objects">Copying SKiDL Objects</h2>

<p>Instead of creating a SKiDL object from scratch, sometimes it’s easier to just
copy an existing object. Here are some examples of creating a resistor and then making
some copies of it:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; r1 = Part('device', 'R', value=500)
&gt;&gt;&gt; r2 = r1.copy()                         # Make a single copy of the resistor.
&gt;&gt;&gt; r3 = r1.copy(value='1K')               # Make a single copy, but give it a different value.
&gt;&gt;&gt; r4 = r1(value='1K')                    # You can also call the object directly to make copies.
&gt;&gt;&gt; r5, r6, r7 = r1(3)                     # Make 3 copies of the resistor.
&gt;&gt;&gt; r8, r9, r10 = r1(value=[110,220,330])  # Make 3 copies, each with a different value.
&gt;&gt;&gt; r11, r12 = 2 * r1                      # Make copies using the '*' operator.
</code></pre>
</div>

<p>In some cases it’s clearer to create parts by copying a <em>template part</em> that
doesn’t actually get included in the netlist for the circuitry.
This is done like so:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; r_template = Part('device', 'R', dest=TEMPLATE)  # Create a resistor just for copying.
&gt;&gt;&gt; r1 = r_template(value='1K')  # Make copy that becomes part of the actual circuitry.
</code></pre>
</div>

<h2 id="accessing-part-pins-and-bus-lines">Accessing Part Pins and Bus Lines</h2>

<p>You can access the pins on a part or the individual nets of a bus
using numbers, slices, strings, and regular expressions, either singly or in any combination.</p>

<p>Suppose you have a PIC10 processor in a six-pin package:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10 = Part('microchip_pic10mcu', 'pic10f220-i/ot')
&gt;&gt;&gt; pic10

PIC10F220-I/OT: PIC10F222, 512W Flash, 24B SRAM, SOT-23-6
    Pin U1/1/ICSPDAT/AN0/GP0/BIDIRECTIONAL
    Pin U1/2/VSS/POWER-IN
    Pin U1/3/ICSPCLK/AN1/GP1/BIDIRECTIONAL
    Pin U1/4/T0CKI/FOSC4/GP2/BIDIRECTIONAL
    Pin U1/5/VDD/POWER-IN
    Pin U1/6/Vpp/~MCLR~/GP3/INPUT
</code></pre>
</div>

<p>The most natural way to access one of its pins is to give the pin number
in brackets:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10[3]
Pin U1/3/ICSPCLK/AN1/GP1/BIDIRECTIONAL
</code></pre>
</div>

<p>(If you have a part in a BGA package with pins numbers like <code class="highlighter-rouge">C11</code>, then
you’ll have to enter the pin number as a quoted string like ‘<code class="highlighter-rouge">C11</code>’.)</p>

<p>You can also get several pins at once in a list:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10[3,1,6]
[Pin U1/3/ICSPCLK/AN1/GP1/BIDIRECTIONAL, Pin U1/1/ICSPDAT/AN0/GP0/BIDIRECTIONAL, Pin U1/6/Vpp/~MCLR~/GP3/INPUT]
</code></pre>
</div>

<p>You can even use Python slice notation:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10[2:4]  # Get pins 2 through 4.
[Pin U1/2/VSS/POWER-IN, Pin U1/3/ICSPCLK/AN1/GP1/BIDIRECTIONAL, Pin U1/4/T0CKI/FOSC4/GP2/BIDIRECTIONAL]
&gt;&gt;&gt; pic10[4:2]  # Get pins 4 through 2.
[Pin U1/4/T0CKI/FOSC4/GP2/BIDIRECTIONAL, Pin U1/3/ICSPCLK/AN1/GP1/BIDIRECTIONAL, Pin U1/2/VSS/POWER-IN]
&gt;&gt;&gt; pic10[:]    # Get all the pins.
[Pin U1/1/ICSPDAT/AN0/GP0/BIDIRECTIONAL, Pin U1/2/VSS/POWER-IN, Pin U1/3/ICSPCLK/AN1/GP1/BIDIRECTIONAL, Pin U1/4/T0CKI/FOSC4/GP2/BIDIRECTIONAL, Pin U1/5/VDD/POWER-IN, Pin U1/6/Vpp/~MCLR~/GP3/INPUT]
</code></pre>
</div>

<p>(It’s important to note that the slice notation used by SKiDL for parts is slightly
different than standard Python. In Python, a slice <code class="highlighter-rouge">n:m</code> would fetch indices
<code class="highlighter-rouge">n</code>, <code class="highlighter-rouge">n+1</code>, <code class="highlighter-rouge">...</code>, <code class="highlighter-rouge">m-1</code>. With SKiDL, it actually fetches all the
way up to the last number: <code class="highlighter-rouge">n</code>, <code class="highlighter-rouge">n+1</code>, <code class="highlighter-rouge">...</code>, <code class="highlighter-rouge">m-1</code>, <code class="highlighter-rouge">m</code>.
The reason for doing this is that most electronics designers are used to
the bounds on a slice including both endpoints. Perhaps it is a mistake to
do it this way. We’ll see…)</p>

<p>In addition to the bracket notation, you can also get a single pin using an attribute name
that begins with a ‘<code class="highlighter-rouge">p</code>’ followed by the pin number:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10.p2
Pin U1/2/VSS/POWER-IN
</code></pre>
</div>

<p>Instead of pin numbers, sometimes it makes the design intent more clear to 
access pins by their names.
For example, it’s more obvious that a voltage supply net is being
attached to the power pin of the processor when it’s expressed like this:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">pic10</span><span class="p">[</span><span class="s">'VDD'</span><span class="p">]</span> <span class="o">+=</span> <span class="n">supply_5V</span>
</code></pre>
</div>

<p>Like pin numbers, pin names can also be used as attributes to access the pin:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10.VDD
Pin U1/5/VDD/POWER-IN
</code></pre>
</div>

<p>You can use multiple names or regular expressions to get more than one pin:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10['VDD','VSS']
[Pin U1/5/VDD/POWER-IN, Pin U1/2/VSS/POWER-IN]
&gt;&gt;&gt; pic10['.*gp[1-3]']
[Pin U1/3/ICSPCLK/AN1/GP1/BIDIRECTIONAL, Pin U1/4/T0CKI/FOSC4/GP2/BIDIRECTIONAL, Pin U1/6/Vpp/~MCLR~/GP3/INPUT]
</code></pre>
</div>

<p>It can be tedious and error prone entering all the quote marks if you’re accessing
many pin names. SKiDL lets you enter a single, comma-delimited string of
pin names:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10['.*GP0, .*GP1, .*GP2']
[Pin U1/1/ICSPDAT/AN0/GP0/BIDIRECTIONAL, Pin U1/3/ICSPCLK/AN1/GP1/BIDIRECTIONAL, Pin U1/4/T0CKI/FOSC4/GP2/BIDIRECTIONAL]
</code></pre>
</div>

<p>Some parts have sequentially-numbered sets of pins like the address and data buses of a RAM.
SKiDL lets you access these pins using a slice-like notation in a string like so:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; ram = Part('memory', 'sram_512ko')
&gt;&gt;&gt; ram['D[0:7]']
[Pin U1/13/D0/TRISTATE, Pin U1/14/D1/TRISTATE, Pin U1/15/D2/TRISTATE, Pin U1/17/D3/TRISTATE, Pin U1/18/D4/TRISTATE, Pin U1/19/D5/TRISTATE, Pin U1/20/D6/TRISTATE, Pin U1/21/D7/TRISTATE]
</code></pre>
</div>

<p>Or you can access the pins in the reverse order:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; ram = Part('memory', 'sram_512ko')
&gt;&gt;&gt; ram['D[7:0]']
[Pin U2/21/D7/TRISTATE, Pin U2/20/D6/TRISTATE, Pin U2/19/D5/TRISTATE, Pin U2/18/D4/TRISTATE, Pin U2/17/D3/TRISTATE, Pin U2/15/D2/TRISTATE, Pin U2/14/D1/TRISTATE, Pin U2/13/D0/TRISTATE]
</code></pre>
</div>

<p><code class="highlighter-rouge">Part</code> objects also provide the <code class="highlighter-rouge">get_pins()</code> function which can select pins in even more ways.
For example, this would get every bidirectional pin of the processor:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10.get_pins(func=Pin.BIDIR)
[Pin U1/1/ICSPDAT/AN0/GP0/BIDIRECTIONAL, Pin U1/3/ICSPCLK/AN1/GP1/BIDIRECTIONAL, Pin U1/4/T0CKI/FOSC4/GP2/BIDIRECTIONAL]
</code></pre>
</div>

<p>Accessing the individual nets of a bus works similarly to accessing part pins:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; a = Net('NET_A')  # Create a named net.
&gt;&gt;&gt; b = Bus('BUS_B', 8, a)  # Create a nine-bit bus.
&gt;&gt;&gt; b
BUS_B:
        BUS_B0:  # Note how the individual nets of the bus are named.
        BUS_B1:
        BUS_B2:
        BUS_B3:
        BUS_B4:
        BUS_B5:
        BUS_B6:
        BUS_B7:
        NET_A:   # The last net retains its original name.
&gt;&gt;&gt; b[0]  # Get the first net of the bus.
BUS_B0:
&gt;&gt;&gt; b[4,8]  # Get the fifth and ninth bus lines.
[BUS_B4: , NET_A: ]
&gt;&gt;&gt; b[3:0]  # Get the first four bus lines in reverse order.
[BUS_B3: , BUS_B2: , BUS_B1: , BUS_B0: ]
&gt;&gt;&gt; b['BUS_B.*']  # Get all the bus lines except the last one.
[BUS_B0: , BUS_B1: , BUS_B2: , BUS_B3: , BUS_B4: , BUS_B5: , BUS_B6: , BUS_B7: ]
&gt;&gt;&gt; b['NET_A']  # Get the last bus line.
NET_A:
</code></pre>
</div>

<h2 id="making-connections">Making Connections</h2>

<p>Pins, nets, parts and buses can all be connected together in various ways, but
the primary rule of SKiDL connections is:</p>

<blockquote>
  <blockquote>
    <p><strong>The <code class="highlighter-rouge">+=</code> operator is the only way to make connections!</strong></p>
  </blockquote>
</blockquote>

<p>At times you’ll mistakenly try to make connections using the 
assignment operator (<code class="highlighter-rouge">=</code>). In many cases, SKiDL warns you if you do that,
but there are situations where it can’t (because
Python is a general-purpose programming language where
assignment is a necessary operation).
So remember the primary rule!</p>

<p>After the primary rule, the next thing to remember is that SKiDL’s main
purpose is creating netlists. To that end, it handles four basic, connection operations:</p>

<p><strong>Pin-to-Net</strong>:
    A pin is connected to a net, adding it to the list of pins
    connected to that net. If the pin is already attached to other nets,
    then those nets are connected to this net as well.</p>

<p><strong>Net-to-Pin</strong>: 
    This is the same as doing a pin-to-net connection.</p>

<p><strong>Pin-to-Pin</strong>:
    A net is created and both pins are attached to it. If one or
    both pins are already connected to other nets, then those nets are connected
    to the newly-created net as well.</p>

<p><strong>Net-to-Net</strong>:
    Connecting one net to another <em>merges</em> the pins on both nets
    onto a single, larger net.</p>

<p>For each type of connection operation, there are three variants based on
the number of things being connected:</p>

<p><strong>One-to-One</strong>:
    This is the most frequent type of connection, for example, connecting one
    pin to another or connecting a pin to a net.</p>

<p><strong>One-to-Many</strong>:
    This mainly occurs when multiple pins are connected to the same net, like
    when multiple ground pins of a chip are connected to the circuit ground net.</p>

<p><strong>Many-to-Many</strong>:
    This usually involves bus connections to a part, such as connecting
    a bus to the data or address pins of a processor. For this variant, there must be the
    same number of things to connect in each set, e.g. you can’t connect
    three pins to four nets.</p>

<p>As a first example, let’s connect a net to a pin on a part:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10 = Part('microchip_pic10mcu','pic10f220-i/ot')  # Get a part.
&gt;&gt;&gt; io = Net('IO_NET')    # Create a net.
&gt;&gt;&gt; pic10['.*GP0'] += io  # Connect the net to a part pin.
&gt;&gt;&gt; io                    # Show the pins connected to the net.
IO_NET: Pin U1/1/ICSPDAT/AN0/GP0/BIDIRECTIONAL
</code></pre>
</div>

<p>You can do the same operation in reverse by connecting the part pin to the net
with the same result:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10 = Part('microchip_pic10mcu','pic10f220-i/ot')
&gt;&gt;&gt; io = Net('IO_NET')
&gt;&gt;&gt; io += pic10['.*GP0']  # Connect a part pin to the net.
&gt;&gt;&gt; io
IO_NET: Pin U1/1/ICSPDAT/AN0/GP0/BIDIRECTIONAL
</code></pre>
</div>

<p>You can also connect a pin directly to another pin.
In this case, an <em>implicit net</em> will be created between the pins that you can
access using the <code class="highlighter-rouge">net</code> attribute of either part pin:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10['.*GP1'] += pic10['.*GP2']  # Connect two pins together.
&gt;&gt;&gt; pic10['.*GP1'].net     # Show the net connected to the pin.
N$1: Pin U1/3/ICSPCLK/AN1/GP1/BIDIRECTIONAL, Pin U1/4/T0CKI/FOSC4/GP2/BIDIRECTIONAL
&gt;&gt;&gt; pic10['.*GP2'].net     # Show the net connected to the other pin. Same thing!
N$1: Pin U1/3/ICSPCLK/AN1/GP1/BIDIRECTIONAL, Pin U1/4/T0CKI/FOSC4/GP2/BIDIRECTIONAL
</code></pre>
</div>

<p>You can connect multiple pins together, all at once:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10[1] += pic10[2,3,6]
&gt;&gt;&gt; pic10[1].net
N$1: Pin U1/1/ICSPDAT/AN0/GP0/BIDIRECTIONAL, Pin U1/2/VSS/POWER-IN, Pin U1/3/ICSPCLK/AN1/GP1/BIDIRECTIONAL, Pin U1/6/Vpp/~MCLR~/GP3/INPUT
</code></pre>
</div>

<p>Or you can do it incrementally:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10[1] += pic10[2]
&gt;&gt;&gt; pic10[1] += pic10[3]
&gt;&gt;&gt; pic10[1] += pic10[6]
&gt;&gt;&gt; pic10[1].net
N$1: Pin U1/1/ICSPDAT/AN0/GP0/BIDIRECTIONAL, Pin U1/2/VSS/POWER-IN, Pin U1/3/ICSPCLK/AN1/GP1/BIDIRECTIONAL, Pin U1/6/Vpp/~MCLR~/GP3/INPUT
</code></pre>
</div>

<p>If you connect pins on separate nets together, then all the pins are merged onto the same net:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10[1] += pic10[2]  # Put pins 1 &amp; 2 on one net.
&gt;&gt;&gt; pic10[1].net
N$1: Pin U1/1/ICSPDAT/AN0/GP0/BIDIRECTIONAL, Pin U1/2/VSS/POWER-IN
&gt;&gt;&gt; pic10[3] += pic10[4]  # Put pins 3 &amp; 4 on another net.
&gt;&gt;&gt; pic10[3].net
N$2: Pin U1/3/ICSPCLK/AN1/GP1/BIDIRECTIONAL, Pin U1/4/T0CKI/FOSC4/GP2/BIDIRECTIONAL
&gt;&gt;&gt; pic10[1] += pic10[4]  # Connect two pins from different nets.
&gt;&gt;&gt; pic10[3].net          # Now all the pins are on the same net!
N$2: Pin U1/1/ICSPDAT/AN0/GP0/BIDIRECTIONAL, Pin U1/2/VSS/POWER-IN, Pin U1/3/ICSPCLK/AN1/GP1/BIDIRECTIONAL, Pin U1/4/T0CKI/FOSC4/GP2/BIDIRECTIONAL
</code></pre>
</div>

<p>Here’s an example of connecting a three-bit bus to three pins on a part:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10 = Part('microchip_pic10mcu','pic10f220-i/ot')
&gt;&gt;&gt; pic10

PIC10F220-I/OT: PIC10F222, 512W Flash, 24B SRAM, SOT-23-6
    Pin U1/1/ICSPDAT/AN0/GP0/BIDIRECTIONAL
    Pin U1/2/VSS/POWER-IN
    Pin U1/3/ICSPCLK/AN1/GP1/BIDIRECTIONAL
    Pin U1/4/T0CKI/FOSC4/GP2/BIDIRECTIONAL
    Pin U1/5/VDD/POWER-IN
    Pin U1/6/Vpp/~MCLR~/GP3/INPUT
&gt;&gt;&gt; b = Bus('GP', 3)        # Create a 3-bit bus.
&gt;&gt;&gt; pic10[4,3,1] += b[2:0]  # Connect bus to part pins, one-to-one.
&gt;&gt;&gt; b
GP:
        GP0: Pin U1/1/ICSPDAT/AN0/GP0/BIDIRECTIONAL
        GP1: Pin U1/3/ICSPCLK/AN1/GP1/BIDIRECTIONAL
        GP2: Pin U1/4/T0CKI/FOSC4/GP2/BIDIRECTIONAL
</code></pre>
</div>

<p>But SKiDL will warn you if there aren’t the same number of things to
connect on each side:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10[4,3,1] += b[1:0]  # Too few bus lines for the pins!
ERROR: Connection mismatch 3 != 2!
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "c:\xesscorp\kicad\tools\skidl\skidl\skidl.py", line 3330, in __iadd__
    raise Exception
Exception
</code></pre>
</div>

<h2 id="making-parallel-and-serial-networks">Making Parallel and Serial Networks</h2>

<p>The previous section showed some general-purpose techniques for connecting parts,
but SKiDL also has some specialized syntax for wiring two-pin components
in parallel or serial.
For example, here is a network of four resistors connected in series
between power and ground:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>vcc, gnd = Net('VCC'), Net('GND')
r1, r2, r3, r4 = Part('device', 'R', dest=TEMPLATE) * 4
ser_ntwk = vcc &amp; r1 &amp; r2 &amp; r3 &amp; r4 &amp; gnd
</code></pre>
</div>

<p>It’s also possible to connect the resistors in parallel between power and ground:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>par_ntwk = vcc &amp; (r1 | r2 | r3 | r4) &amp; gnd
</code></pre>
</div>

<p>Or you can do something like placing pairs of resistors in series and then paralleling
those combinations like this:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>combo_ntwk = vcc &amp; ((r1 &amp; r2) | (r3 &amp; r4)) &amp; gnd
</code></pre>
</div>

<p>The examples above work with <em>non-polarized</em> components, but what about parts
like diodes? In that case, you have to specify the pins <em>explicitly</em> with the
first pin connected to the preceding part and the second pin to the following part:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>d1 = Part('device', 'D')
polar_ntwk = vcc &amp; r1 &amp; d1['A,K'] &amp; gnd  # Diode anode connected to resistor and cathode to ground.
</code></pre>
</div>

<p>Explicitly listing the pins also lets you use multi-pin parts with networks.
For example, here’s an NPN-transistor amplifier:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>q1 = Part('device', 'Q_NPN_ECB')
ntwk_ce = vcc &amp; r1 &amp; q1['C,E'] &amp; gnd  # VCC through load resistor to collector and emitter attached to ground.
ntwk_b = r2 &amp; q1['B']  # Resistor attached to base.
</code></pre>
</div>

<p>That’s all well and good, but how do you connect to internal points in these networks where
the interesting things are happening?
For instance, how do you apply an input to the transistor circuit and then connect
to the output?
One way is by inserting nets inside the networks:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>inp, outp = Net('INPUT'), Net('OUTPUT')
ntwk_ce = vcc &amp; r1 &amp; outp &amp; q1['C,E'] &amp; gnd  # Connect net outp to the junction of the resistor and transistor collector.
ntwk_b = inp &amp; r2 &amp; q1['B']  # Connect net inp to the resistor driving the transistor base.
</code></pre>
</div>

<p>After that’s done, the <code class="highlighter-rouge">inp</code> and <code class="highlighter-rouge">outp</code> nets can be connected to other points in the circuit.</p>

<h2 id="units-within-parts">Units Within Parts</h2>

<p>Some components may contain smaller <em>units</em> that operate independently of the
component as a whole.
For example, an operational amplifier chip might contain two individual opamp units,
each capable of operating on their own set of inputs and outputs.</p>

<p>Some library parts may already have predefined units, but you can add them to
any part.
For example, a four-pin <em>resistor network</em> might contain two resistors:
one attached between pins 1 and 4, and the other bewtween pins 2 and 3.
Each resistor could be assigned to a unit as follows:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; rn = Part('device', 'R_Pack02')
&gt;&gt;&gt; rn.make_unit('A', 1, 4)  # Make a unit called 'A' for the first resistor.

 R_Pack02 (): 2 Resistor network, parallel topology, DIP package
    Pin RN1/4/R1.2/PASSIVE
    Pin RN1/1/R1.1/PASSIVE
&gt;&gt;&gt; rn.make_unit('B', 2, 3)  # Now make a unit called 'B' for the second resistor.

 R_Pack02 (): 2 Resistor network, parallel topology, DIP package
    Pin RN1/2/R2.1/PASSIVE
    Pin RN1/3/R2.2/PASSIVE
&gt;&gt;&gt; rn.unit['A'][1, 4] += Net(), Net()
</code></pre>
</div>

<p>Once the units are defined, you can use them just like any part:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; rn.unit['A'][1,4] += Net(), Net()  # Connect resistor A to two nets.
&gt;&gt;&gt; rn.unit['B'][2,3] += rn.unit['A'][1,4]  # Connect resistor B in parallel with resistor A.
</code></pre>
</div>

<p>Now this isn’t all that useful because you still have to remember which pins
are assigned to each unit, and if you wanted to swap the resistors you would have
to change the unit names <em>and the pins numbers!</em>.
In order to get around this inconvenience, you could assign <em>aliases</em> to each
pin like this:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; rn = Part('device', 'R_Pack02')
&gt;&gt;&gt; rn.make_unit('A', 1, 4)

 R_Pack02 (): 2 Resistor network, parallel topology, DIP package
    Pin RN1/4/R1.2/PASSIVE
    Pin RN1/1/R1.1/PASSIVE
&gt;&gt;&gt; rn.make_unit('B', 2, 3)

 R_Pack02 (): 2 Resistor network, parallel topology, DIP package
    Pin RN1/3/R2.2/PASSIVE
    Pin RN1/2/R2.1/PASSIVE
&gt;&gt;&gt; rn.unit['A'].set_pin_alias('L',1) # Alias 'L' of pin 1 on left-side of package.
&gt;&gt;&gt; rn.unit['A'].set_pin_alias('R',4) # Alias 'R' of pin 4 on right-side of package.
&gt;&gt;&gt; rn.unit['B'].set_pin_alias('L',2) # Alias 'L' of pin 2 on left-side.
&gt;&gt;&gt; rn.unit['B'].set_pin_alias('R',3) # Alias 'R' of pin 3 on right-side.
</code></pre>
</div>

<p>Now the same connections can be made using the pin aliases:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; rn.unit['A']['L,R'] += Net(), Net()  # Connect resistor A to two nets.
&gt;&gt;&gt; rn.unit['B']['L,R'] += rn.unit['A']['L,R']  # Connect resistor B in parallel with resistor A.
</code></pre>
</div>

<p>In this case, if you wanted to swap the A and B resistors, you only need to change
their unit labels.
The pin aliases don’t need to be altered.</p>

<p>If you find the <code class="highlighter-rouge">unit[...]</code> notation cumbersome, units can also be accessed by
using their names as attributes:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; rn.A['L,R'] += Net(), Net()  # Connect resistor A to two nets.
&gt;&gt;&gt; rn.B['L,R'] += rn.A['L,R']   # Connect resistor B in parallel with resistor A.
</code></pre>
</div>

<h2 id="hierarchy">Hierarchy</h2>

<p>SKiDL supports the encapsulation of parts, nets and buses into modules
that can be replicated to reduce the design effort, and can be used in
other modules to create a functional hierarchy.
It does this using Python’s built-in machinery for defining and calling functions
so there’s almost nothing new to learn.</p>

<p>As an example, here’s the voltage divider as a module:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">skidl</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c"># Define the voltage divider module. The @subcircuit decorator </span>
<span class="c"># handles some skidl housekeeping that needs to be done.</span>
<span class="nd">@subcircuit</span>
<span class="k">def</span> <span class="nf">vdiv</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">outp</span><span class="p">):</span>
    <span class="s">"""Divide inp voltage by 3 and place it on outp net."""</span>
    <span class="n">rup</span> <span class="o">=</span> <span class="n">Part</span><span class="p">(</span><span class="s">'device'</span><span class="p">,</span> <span class="s">'R'</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s">'1K'</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="s">'Resistor_SMD.pretty:R_0805_2012Metric'</span><span class="p">)</span>
    <span class="n">rlo</span> <span class="o">=</span> <span class="n">Part</span><span class="p">(</span><span class="s">'device'</span><span class="p">,</span><span class="s">'R'</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s">'500'</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="s">'Resistor_SMD.pretty:R_0805_2012Metric'</span><span class="p">)</span>
    <span class="n">rup</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">inp</span><span class="p">,</span> <span class="n">outp</span>
    <span class="n">rlo</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">outp</span><span class="p">,</span> <span class="n">gnd</span>

<span class="n">gnd</span> <span class="o">=</span> <span class="n">Net</span><span class="p">(</span><span class="s">'GND'</span><span class="p">)</span>         <span class="c"># GLobal ground net.</span>
<span class="n">input_net</span> <span class="o">=</span> <span class="n">Net</span><span class="p">(</span><span class="s">'IN'</span><span class="p">)</span>    <span class="c"># Net with the voltage to be divided.</span>
<span class="n">output_net</span> <span class="o">=</span> <span class="n">Net</span><span class="p">(</span><span class="s">'OUT'</span><span class="p">)</span>  <span class="c"># Net with the divided voltage.</span>

<span class="c"># Instantiate the voltage divider and connect it to the input &amp; output nets.</span>
<span class="n">vdiv</span><span class="p">(</span><span class="n">input_net</span><span class="p">,</span> <span class="n">output_net</span><span class="p">)</span>

<span class="n">generate_netlist</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
</code></pre>
</div>

<p>For the most part, <code class="highlighter-rouge">vdiv</code> is just a standard Python function:
it accepts inputs, it performs operations on them, and it could return
outputs (but in this case, it doesn’t need to).
Other than the <code class="highlighter-rouge">@subcircuit</code> decorator that appears before the function definition,
<code class="highlighter-rouge">vdiv</code> is just a Python function and it can do anything that a Python function can do.</p>

<p>Here’s the netlist that’s generated:</p>

<div class="language-text highlighter-rouge"><pre class="highlight"><code>(export (version D)
  (design
    (source "C:\TEMP\skidl tests\hier_example.py")
    (date "04/20/2017 09:39 AM")
    (tool "SKiDL (0.0.12)"))
  (components
    (comp (ref R1)
      (value 1K)
      (footprint Resistor_SMD.pretty:R_0805_2012Metric)
      (fields
        (field (name keywords) "r res resistor")
        (field (name description) Resistor))
      (libsource (lib device) (part R)))
    (comp (ref R2)
      (value 500)
      (footprint Resistor_SMD.pretty:R_0805_2012Metric)
      (fields
        (field (name keywords) "r res resistor")
        (field (name description) Resistor))
      (libsource (lib device) (part R))))
  (nets
    (net (code 0) (name GND)
      (node (ref R2) (pin 2)))
    (net (code 1) (name IN)
      (node (ref R1) (pin 1)))
    (net (code 2) (name OUT)
      (node (ref R1) (pin 2))
      (node (ref R2) (pin 1))))
)
</code></pre>
</div>

<p>For an example of a multi-level hierarchy, the <code class="highlighter-rouge">multi_vdiv</code> module shown below
can use the <code class="highlighter-rouge">vdiv</code> module to divide a voltage multiple times:</p>

<p><a name="multilevel_hierarchy_example"></a></p>
<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">skidl</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c"># Define the voltage divider module.</span>
<span class="nd">@subcircuit</span>
<span class="k">def</span> <span class="nf">vdiv</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">outp</span><span class="p">):</span>
    <span class="s">"""Divide inp voltage by 3 and place it on outp net."""</span>
    <span class="n">rup</span> <span class="o">=</span> <span class="n">Part</span><span class="p">(</span><span class="s">'device'</span><span class="p">,</span> <span class="s">'R'</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s">'1K'</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="s">'Resistor_SMD.pretty:R_0805_2012Metric'</span><span class="p">)</span>
    <span class="n">rlo</span> <span class="o">=</span> <span class="n">Part</span><span class="p">(</span><span class="s">'device'</span><span class="p">,</span><span class="s">'R'</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s">'500'</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="s">'Resistor_SMD.pretty:R_0805_2012Metric'</span><span class="p">)</span>
    <span class="n">rup</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">inp</span><span class="p">,</span> <span class="n">outp</span>
    <span class="n">rlo</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">outp</span><span class="p">,</span> <span class="n">gnd</span>

<span class="nd">@subcircuit</span>
<span class="k">def</span> <span class="nf">multi_vdiv</span><span class="p">(</span><span class="n">repeat</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">outp</span><span class="p">):</span>
    <span class="s">"""Divide inp voltage by 3 ** repeat and place it on outp net."""</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">repeat</span><span class="p">):</span>
        <span class="n">out_net</span> <span class="o">=</span> <span class="n">Net</span><span class="p">()</span>     <span class="c"># Create an output net for the current stage.</span>
        <span class="n">vdiv</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">out_net</span><span class="p">)</span>  <span class="c"># Instantiate a divider stage.</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="n">out_net</span>       <span class="c"># The output net becomes the input net for the next stage.</span>
    <span class="n">outp</span> <span class="o">+=</span> <span class="n">out_net</span>         <span class="c"># Connect the output from the last stage to the module output net.</span>

<span class="n">gnd</span> <span class="o">=</span> <span class="n">Net</span><span class="p">(</span><span class="s">'GND'</span><span class="p">)</span>         <span class="c"># GLobal ground net.</span>
<span class="n">input_net</span> <span class="o">=</span> <span class="n">Net</span><span class="p">(</span><span class="s">'IN'</span><span class="p">)</span>    <span class="c"># Net with the voltage to be divided.</span>
<span class="n">output_net</span> <span class="o">=</span> <span class="n">Net</span><span class="p">(</span><span class="s">'OUT'</span><span class="p">)</span>  <span class="c"># Net with the divided voltage.</span>
<span class="n">multi_vdiv</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">input_net</span><span class="p">,</span> <span class="n">output_net</span><span class="p">)</span>  <span class="c"># Run the input through 3 voltage dividers.</span>

<span class="n">generate_netlist</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
</code></pre>
</div>

<p>(For the EE’s out there: <em>yes, I know cascading three simple voltage dividers
will not multiplicatively scale the input voltage because of the
input and output impedances of each stage!</em>
It’s just the simplest example I could use to show hierarchy.)</p>

<p>And here’s the resulting netlist:</p>

<div class="language-text highlighter-rouge"><pre class="highlight"><code>(export (version D)
  (design
    (source "C:\TEMP\skidl tests\multi_hier_example.py")
    (date "04/20/2017 09:43 AM")
    (tool "SKiDL (0.0.12)"))
  (components
    (comp (ref R1)
      (value 1K)
      (footprint Resistor_SMD.pretty:R_0805_2012Metric)
      (fields
        (field (name keywords) "r res resistor")
        (field (name description) Resistor))
      (libsource (lib device) (part R)))
    (comp (ref R2)
      (value 500)
      (footprint Resistor_SMD.pretty:R_0805_2012Metric)
      (fields
        (field (name keywords) "r res resistor")
        (field (name description) Resistor))
      (libsource (lib device) (part R)))
    (comp (ref R3)
      (value 1K)
      (footprint Resistor_SMD.pretty:R_0805_2012Metric)
      (fields
        (field (name keywords) "r res resistor")
        (field (name description) Resistor))
      (libsource (lib device) (part R)))
    (comp (ref R4)
      (value 500)
      (footprint Resistor_SMD.pretty:R_0805_2012Metric)
      (fields
        (field (name keywords) "r res resistor")
        (field (name description) Resistor))
      (libsource (lib device) (part R)))
    (comp (ref R5)
      (value 1K)
      (footprint Resistor_SMD.pretty:R_0805_2012Metric)
      (fields
        (field (name keywords) "r res resistor")
        (field (name description) Resistor))
      (libsource (lib device) (part R)))
    (comp (ref R6)
      (value 500)
      (footprint Resistor_SMD.pretty:R_0805_2012Metric)
      (fields
        (field (name keywords) "r res resistor")
        (field (name description) Resistor))
      (libsource (lib device) (part R))))
  (nets
    (net (code 0) (name GND)
      (node (ref R2) (pin 2))
      (node (ref R4) (pin 2))
      (node (ref R6) (pin 2)))
    (net (code 1) (name IN)
      (node (ref R1) (pin 1)))
    (net (code 2) (name N$1)
      (node (ref R1) (pin 2))
      (node (ref R2) (pin 1))
      (node (ref R3) (pin 1)))
    (net (code 3) (name N$2)
      (node (ref R3) (pin 2))
      (node (ref R4) (pin 1))
      (node (ref R5) (pin 1)))
    (net (code 4) (name OUT)
      (node (ref R5) (pin 2))
      (node (ref R6) (pin 1))))
)
</code></pre>
</div>

<h2 id="libraries">Libraries</h2>

<p>As you’ve already seen, SKiDL gets its parts from <em>part libraries</em>.
By default, SKiDL finds the libraries provided by KiCad (using the <code class="highlighter-rouge">KICAD_SYMBOL_DIR</code>
environment variable), so if that’s all you need then you’re all set.</p>

<p>Currently, SKiDL supports the library formats for the following ECAD tools:</p>

<ul>
  <li><code class="highlighter-rouge">KICAD</code>: KiCad schematic part libraries.</li>
  <li><code class="highlighter-rouge">SKIDL</code>: Schematic parts stored as SKiDL/Python modules.</li>
</ul>

<p>You can set the default library format you want to use in your SKiDL script like so:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">set_default_tool</span><span class="p">(</span><span class="n">KICAD</span><span class="p">)</span>  <span class="c"># KiCad is the default library format.</span>
<span class="n">set_default_tool</span><span class="p">(</span><span class="n">SKIDL</span><span class="p">)</span>  <span class="c"># Now SKiDL is the default library format.</span>
</code></pre>
</div>

<p>You can select the directories where SKiDL looks for parts using the 
<code class="highlighter-rouge">lib_search_paths</code> dictionary:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">lib_search_paths</span><span class="p">[</span><span class="n">SKIDL</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s">'.'</span><span class="p">,</span> <span class="s">'..'</span><span class="p">,</span> <span class="s">'C:</span><span class="se">\\</span><span class="s">temp'</span><span class="p">]</span>
<span class="n">lib_search_paths</span><span class="p">[</span><span class="n">KICAD</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'C:</span><span class="se">\\</span><span class="s">my</span><span class="se">\\</span><span class="s">kicad</span><span class="se">\\</span><span class="s">libs'</span><span class="p">)</span>
</code></pre>
</div>

<p>You can convert a KiCad library into the SKiDL format by exporting it:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">kicad_lib</span> <span class="o">=</span> <span class="n">SchLib</span><span class="p">(</span><span class="s">'device'</span><span class="p">,</span> <span class="n">tool</span><span class="o">=</span><span class="n">KICAD</span><span class="p">)</span>       <span class="c"># Open a KiCad library.</span>
<span class="n">kicad_lib</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="s">'my_skidl_lib'</span><span class="p">)</span>               <span class="c"># Export it into a file in SKiDL format.</span>
<span class="n">skidl_lib</span> <span class="o">=</span> <span class="n">SchLib</span><span class="p">(</span><span class="s">'my_skidl_lib'</span><span class="p">,</span> <span class="n">tool</span><span class="o">=</span><span class="n">SKIDL</span><span class="p">)</span> <span class="c"># Create a SKiDL library object from the new file.</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skidl_lib</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">kicad_lib</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'As expected, both libraries have the same number of parts!'</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'Something went wrong!'</span><span class="p">)</span>
<span class="n">diode</span> <span class="o">=</span> <span class="n">Part</span><span class="p">(</span><span class="n">skidl_lib</span><span class="p">,</span> <span class="s">'D'</span><span class="p">)</span>                   <span class="c"># Instantiate a diode from the SKiDL library.</span>
</code></pre>
</div>

<p>You can make ad-hoc libraries just by creating a SchLib object and adding
Part objects to it:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">my_lib</span> <span class="o">=</span> <span class="n">SchLib</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">'my_lib'</span><span class="p">)</span>                      <span class="c"># Create an empty library object.</span>
<span class="n">my_part</span> <span class="o">=</span> <span class="n">Part</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">'R'</span><span class="p">,</span> <span class="n">tool</span><span class="o">=</span><span class="n">SKIDL</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="n">TEMPLATE</span><span class="p">)</span> <span class="c"># Create an empty part object template.</span>
<span class="n">my_part</span><span class="o">.</span><span class="n">ref_prefix</span> <span class="o">=</span> <span class="s">'R'</span>                            <span class="c"># Set the part reference prefix.</span>
<span class="n">my_part</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="s">'resistor'</span>                    <span class="c"># Set the part's description field.</span>
<span class="n">my_part</span><span class="o">.</span><span class="n">keywords</span> <span class="o">=</span> <span class="s">'res resistor'</span>                   <span class="c"># Set the part's keywords.</span>
<span class="n">my_part</span> <span class="o">+=</span> <span class="n">Pin</span><span class="p">(</span><span class="n">num</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">Pin</span><span class="o">.</span><span class="n">PASSIVE</span><span class="p">)</span>             <span class="c"># Add a pin to the part.</span>
<span class="n">my_part</span> <span class="o">+=</span> <span class="n">Pin</span><span class="p">(</span><span class="n">num</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">Pin</span><span class="o">.</span><span class="n">PASSIVE</span><span class="p">)</span>             <span class="c"># Add another pin to the part.</span>
<span class="n">my_lib</span> <span class="o">+=</span> <span class="n">my_part</span>                                   <span class="c"># Add the part to the library.</span>

<span class="n">new_resistor</span> <span class="o">=</span> <span class="n">Part</span><span class="p">(</span><span class="n">my_lib</span><span class="p">,</span> <span class="s">'R'</span><span class="p">)</span>                    <span class="c"># Instantiate the part from the library.</span>
<span class="n">my_lib</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="s">'my_lib'</span><span class="p">)</span>                             <span class="c"># Save the library in a file my_lib.py.</span>
</code></pre>
</div>

<p>Always create a part intended for a library as a template so you don’t inadvertently
add it to the circuit netlist.
Then set the part attributes and create and add pins to the part.
Here are the most common attributes you’ll want to set:</p>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>name</td>
      <td>A string containing the name of the part, e.g. ‘LM35’ for a temperature sensor.</td>
    </tr>
    <tr>
      <td>ref_prefix</td>
      <td>A string containing the prefix for this part’s references, e.g. ‘U’ for ICs.</td>
    </tr>
    <tr>
      <td>description</td>
      <td>A string describing the part, e.g. ‘temperature sensor’.</td>
    </tr>
    <tr>
      <td>keywords</td>
      <td>A string containing keywords about the part, e.g. ‘sensor temperature IC’.</td>
    </tr>
  </tbody>
</table>

<p>When creating a pin, these are the attributes you’ll want to set:</p>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>num</td>
      <td>A string or integer containing the pin number, e.g. 5 or ‘A13’.</td>
    </tr>
    <tr>
      <td>name</td>
      <td>A string containing the name of the pin, e.g. ‘CS’.</td>
    </tr>
    <tr>
      <td>func</td>
      <td>An identifier for the function of the pin.</td>
    </tr>
  </tbody>
</table>

<p>The pin function identifiers are as follows:</p>

<table>
  <thead>
    <tr>
      <th>Identifier</th>
      <th>Pin Function</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Pin.INPUT</td>
      <td>Input pin.</td>
    </tr>
    <tr>
      <td>Pin.OUTPUT</td>
      <td>Output pin.</td>
    </tr>
    <tr>
      <td>Pin.BIDIR</td>
      <td>Bidirectional in/out pin.</td>
    </tr>
    <tr>
      <td>Pin.TRISTATE</td>
      <td>Output pin that goes into a high-impedance state when disabled.</td>
    </tr>
    <tr>
      <td>Pin.PASSIVE</td>
      <td>Pin on a passive component (like a resistor).</td>
    </tr>
    <tr>
      <td>Pin.UNSPEC</td>
      <td>Pin with an unspecified function.</td>
    </tr>
    <tr>
      <td>Pin.PWRIN</td>
      <td>Power input pin (either voltage supply or ground).</td>
    </tr>
    <tr>
      <td>Pin.PWROUT</td>
      <td>Power output pin (like the output of a voltage regulator).</td>
    </tr>
    <tr>
      <td>Pin.OPENCOLL</td>
      <td>Open-collector pin (pulls to ground but not to positive rail).</td>
    </tr>
    <tr>
      <td>Pin.OPENEMIT</td>
      <td>Open-emitter pin (pulls to positive rail but not to ground).</td>
    </tr>
    <tr>
      <td>Pin.NOCONNECT</td>
      <td>A pin that should be left unconnected.</td>
    </tr>
  </tbody>
</table>

<p>SKiDL will also create a library of all the parts used in your design whenever
you use the <code class="highlighter-rouge">generate_netlist()</code> function.
For example, if your SKiDL script is named <code class="highlighter-rouge">my_design.py</code>, then the parts instantiated
in that script will be stored as a SKiDL library in the file <code class="highlighter-rouge">my_design_lib.py</code>.
This can be useful if you’re sending the design to someone who may not have all
the libraries you do.
Just send them <code class="highlighter-rouge">my_design.py</code> and <code class="highlighter-rouge">my_design_lib.py</code> and any parts not found
when they run the script will be fetched from the backup parts in the library.</p>

<h2 id="doodads">Doodads</h2>

<p>SKiDL has a few features that don’t fit into any other
category. Here they are.</p>

<h3 id="no-connects">No Connects</h3>

<p>Sometimes you will use a part, but you won’t use every pin.
The ERC will complain about those unconnected pins:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10 = Part('microchip_pic10mcu','pic10f220-i/ot')
&gt;&gt;&gt; ERC()
ERC WARNING: Unconnected pin: BIDIRECTIONAL pin 1/ICSPDAT/AN0/GP0 of PIC10F220-I/OT/U1.
ERC WARNING: Unconnected pin: POWER-IN pin 2/VSS of PIC10F220-I/OT/U1.
ERC WARNING: Unconnected pin: BIDIRECTIONAL pin 3/ICSPCLK/AN1/GP1 of PIC10F220-I/OT/U1.
ERC WARNING: Unconnected pin: BIDIRECTIONAL pin 4/T0CKI/FOSC4/GP2 of PIC10F220-I/OT/U1.
ERC WARNING: Unconnected pin: POWER-IN pin 5/VDD of PIC10F220-I/OT/U1.
ERC WARNING: Unconnected pin: INPUT pin 6/Vpp/~MCLR~/GP3 of PIC10F220-I/OT/U1.

6 warnings found during ERC.
0 errors found during ERC.
</code></pre>
</div>

<p>If you have pins that you intentionally want to leave unconnected, then
attach them to the special-purpose <code class="highlighter-rouge">NC</code> (no-connect) net and the warnings will
be supressed:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10[1,3,4] += NC
&gt;&gt;&gt; ERC()
ERC WARNING: Unconnected pin: POWER-IN pin 2/VSS of PIC10F220-I/OT/U1.
ERC WARNING: Unconnected pin: POWER-IN pin 5/VDD of PIC10F220-I/OT/U1.
ERC WARNING: Unconnected pin: INPUT pin 6/Vpp/~MCLR~/GP3 of PIC10F220-I/OT/U1.

3 warnings found during ERC.
0 errors found during ERC.
</code></pre>
</div>

<p>In fact, if you have a part with many pins that are not going to be used,
you can start off by attaching all the pins to the <code class="highlighter-rouge">NC</code> net.
After that, you can attach the pins you’re using to normal nets and they
will be removed from the <code class="highlighter-rouge">NC</code> net:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">my_part</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">NC</span>  <span class="c"># Connect every pin to NC net.</span>
<span class="o">...</span>
<span class="n">my_part</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Net</span><span class="p">()</span>  <span class="c"># Pin 5 is no longer unconnected.</span>
</code></pre>
</div>

<p>The <code class="highlighter-rouge">NC</code> net is the only net for which this happens.
For all other nets, connecting two or more nets to the same pin
merges those nets and all the pins on them together.</p>

<h3 id="net-and-pin-drive-levels">Net and Pin Drive Levels</h3>

<p>Certain parts have power pins that are required to be driven by
a power supply net or else ERC warnings ensue.
This condition is usually satisfied if the power pins are driven by
the output of another part like a voltage regulator.
But if the regulator output passes through something like a 
ferrite bead (to remove noise), then the filtered signal
is no longer a supply net and an ERC warning is issued.</p>

<p>In order to satisfy the ERC, the drive strength of a net can be set manually
using its <code class="highlighter-rouge">drive</code> attribute. As a simple example, consider connecting
a net to the power supply input of a processor and then running
the ERC:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10 = Part('microchip_pic10mcu','pic10f220-i/ot')
&gt;&gt;&gt; a = Net()
&gt;&gt;&gt; pic10['VDD'] += a
&gt;&gt;&gt; ERC()
...
ERC WARNING: Insufficient drive current on net N$1 for pin POWER-IN pin 5/VDD of PIC10F220-I/OT/U1
...
</code></pre>
</div>

<p>This issue is fixed by changing the <code class="highlighter-rouge">drive</code> attribute of the net:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10 = Part('microchip_pic10mcu','pic10f220-i/ot')
&gt;&gt;&gt; a = Net()
&gt;&gt;&gt; pic10['VDD'] += a
&gt;&gt;&gt; a.drive = POWER
&gt;&gt;&gt; ERC()
...
(Insufficient drive warning is no longer present.)
...
</code></pre>
</div>

<p>You can set the <code class="highlighter-rouge">drive</code> attribute at any time to any defined level, but <code class="highlighter-rouge">POWER</code>
is probably the only setting you’ll use.
For any net you create that supplies power to devices in your circuit,
you should probably set its <code class="highlighter-rouge">drive</code> attribute to <code class="highlighter-rouge">POWER</code>.
This is equivalent to attaching power flags to nets in some ECAD packages like KiCad.</p>

<p>You can also set the <code class="highlighter-rouge">drive</code> attribute of part pins to override their default drive level.
This is sometimes useful when you are using an output pin of a part to power
another part.</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; pic10_a = Part('microchip_pic10mcu','pic10f220-I/OT')
&gt;&gt;&gt; pic10_b = Part('microchip_pic10mcu','pic10f220-I/OT')
&gt;&gt;&gt; pic10_b['VDD'] += pic10_a[1]  # Power pic10_b from output pin of pic10_a.
&gt;&gt;&gt; ERC()
ERC WARNING: Insufficient drive current on net N$1 for pin POWER-IN pin 5/VDD of PIC10F220-I/OT/U2
... &lt;additional unconnected pin warnings&gt; ...

&gt;&gt;&gt; pic10_a[1].drive = POWER  # Change drive level of pic10_a output pin.
&gt;&gt;&gt; ERC()
... &lt;unconnected pin warnings, but insufficient drive warning is gone&gt; ...
</code></pre>
</div>

<h3 id="pin-net-bus-equivalencies">Pin, Net, Bus Equivalencies</h3>

<p>Pins, nets, and buses can all be connected to one another in a number of ways.
In order to make them as interchangeable as possible, some additional functions
are defined for each object:</p>

<p><strong><code class="highlighter-rouge">__bool__</code> and <code class="highlighter-rouge">__nonzero__</code></strong>:
    Each object will return <code class="highlighter-rouge">True</code> when used in a boolean operation.
    This can be useful when trying to select an active connection from a set of
    candidates using the <code class="highlighter-rouge">or</code> operator:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; a = Net('A')
&gt;&gt;&gt; b = Bus('B', 8)
&gt;&gt;&gt; c = Pin()
&gt;&gt;&gt; d = a or b or c
&gt;&gt;&gt; d
A:
&gt;&gt;&gt; type(d)
&lt;class 'skidl.Net.Net'&gt;
</code></pre>
</div>

<p><strong>Indexing</strong>:
    Normally, indices can only be used with a Bus object to select one or more bus lines.
    But <code class="highlighter-rouge">Pin</code> and <code class="highlighter-rouge">Net</code> objects can also be indexed as long as the index evaluates to zero:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; a = Net('A')
&gt;&gt;&gt; c = Pin()
&gt;&gt;&gt; a[0] += c[0]
WARNING: Attaching non-part Pin  to a Net A.
&gt;&gt;&gt; a[0] += c[1]
ERROR: Can't use a non-zero index for a pin.
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "C:\xesscorp\KiCad\tools\skidl\skidl\Pin.py", line 251, in __getitem__
    raise Exception
Exception
</code></pre>
</div>

<p><strong>Width</strong>:
    <code class="highlighter-rouge">Bus</code>, <code class="highlighter-rouge">Net</code>, and <code class="highlighter-rouge">Pin</code> objects all support the <code class="highlighter-rouge">width</code> property.
    For a <code class="highlighter-rouge">Bus</code> object, <code class="highlighter-rouge">width</code> returns the number of bus lines it contains.
    For a <code class="highlighter-rouge">Net</code> or <code class="highlighter-rouge">Pin</code> object, <code class="highlighter-rouge">width</code> always returns 1.</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; a = Net('A')
&gt;&gt;&gt; b = Bus('B', 8)
&gt;&gt;&gt; c = Pin()
&gt;&gt;&gt; a.width
1
&gt;&gt;&gt; b.width
8
&gt;&gt;&gt; c.width
1
</code></pre>
</div>

<h3 id="selectively-supressing-erc-messages">Selectively Supressing ERC Messages</h3>

<p>Sometimes a portion of your circuit throws a lot of ERC warnings or errors
even though you know it’s correct.
SKiDL provides flags that allow you to turn off the ERC for selected nets, pins,
and parts like so:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">my_net</span><span class="o">.</span><span class="n">do_erc</span> <span class="o">=</span> <span class="bp">False</span>      <span class="c"># Turns of ERC for this particular net.</span>
<span class="n">my_part</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">do_erc</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c"># Turns off ERC for this pin of this part.</span>
<span class="n">my_part</span><span class="o">.</span><span class="n">do_erc</span> <span class="o">=</span> <span class="bp">False</span>     <span class="c"># Turns off ERC for all the pins of this part.</span>
</code></pre>
</div>

<h1 id="going-really-deep">Going Really Deep</h1>

<p>If all you need to do is design the circuitry for a PCB, then you probably know
all the SKiDL you need to know.
This section will describe the features of SKiDL that might be useful (or not) to
some of the avant-garde circuit designers out there.</p>

<h2 id="circuit-objects">Circuit Objects</h2>

<p>Normally, SKiDL puts parts and nets into a global instance of a <code class="highlighter-rouge">Circuit</code> object
called <code class="highlighter-rouge">default_circuit</code> (which, of course, you never noticed).
But you can create other <code class="highlighter-rouge">Circuit</code> objects:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; my_circuit = Circuit()
</code></pre>
</div>

<p>and then you can create parts, nets and buses and add them to your new circuit:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; my_circuit += Part('device','R')  # Add a resistor to the circuit.
&gt;&gt;&gt; my_circuit += Net('GND')          # Add a net.
&gt;&gt;&gt; my_circuit += Bus('byte_bus', 8)  # Add a bus.
</code></pre>
</div>

<p>In addition to the <code class="highlighter-rouge">+=</code> operator, you can also use the methods <code class="highlighter-rouge">add_parts</code>, <code class="highlighter-rouge">add_nets</code>, and <code class="highlighter-rouge">add_buses</code>.
(There’s also the much less-used <code class="highlighter-rouge">-=</code> operator for removing parts, nets or buses
from a circuit along with the <code class="highlighter-rouge">rmv_parts</code>, <code class="highlighter-rouge">rmv_nets</code>, and <code class="highlighter-rouge">rmv_buses</code> methods.)</p>

<p>You can also place parts, nets, and buses directly into a Circuit object
by using the <code class="highlighter-rouge">circuit</code> parameter of the object constructors:</p>

<div class="language-terminal highlighter-rouge"><pre class="highlight"><code>&gt;&gt;&gt; my_circuit = Circuit()
&gt;&gt;&gt; p = Part('device', 'R', circuit = my_circuit)
&gt;&gt;&gt; n = Net('GND', circuit = my_circuit)
&gt;&gt;&gt; b = Bus('byte_bus', 8, circuit = my_circuit)
</code></pre>
</div>

<p>Hierarchical circuits also work with Circuit objects.
In the previous <a href="#multilevel_hierarchy_example">multi-level hierarchy example</a>,
the subcircuit could be instantiated into a Circuit object like this:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="n">my_circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>   <span class="c"># New Circuit object.</span>

<span class="n">gnd</span> <span class="o">=</span> <span class="n">Net</span><span class="p">(</span><span class="s">'GND'</span><span class="p">)</span>         <span class="c"># GLobal ground net.</span>
<span class="n">input_net</span> <span class="o">=</span> <span class="n">Net</span><span class="p">(</span><span class="s">'IN'</span><span class="p">)</span>    <span class="c"># Net with the voltage to be divided.</span>
<span class="n">output_net</span> <span class="o">=</span> <span class="n">Net</span><span class="p">(</span><span class="s">'OUT'</span><span class="p">)</span>  <span class="c"># Net with the divided voltage.</span>
<span class="n">my_circuit</span> <span class="o">+=</span> <span class="n">gnd</span><span class="p">,</span> <span class="n">input_net</span><span class="p">,</span> <span class="n">output_net</span>  <span class="c"># Move the nets to the new circuit.</span>

<span class="c"># Instantiate the multi-level hierarchical subcircuit into the new Circuit object.</span>
<span class="n">multi_vdiv</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">input_net</span><span class="p">,</span> <span class="n">output_net</span><span class="p">,</span> <span class="n">circuit</span> <span class="o">=</span> <span class="n">my_circuit</span><span class="p">)</span>
</code></pre>
</div>

<p>The actual <code class="highlighter-rouge">circuit</code> parameter is not passed on to the subcircuit.
It’s extracted and any elements created in the subcircuit are sent there instead of
to the default circuit.
(If the <code class="highlighter-rouge">circuit</code> argument is omitted, the subcircuit function uses the
default circuit as the target of its operations.)</p>

<p>You can do all the same operations on a Circuit object that are supported on the 
default circuit, such as:</p>

<div class="language-py highlighter-rouge"><pre class="highlight"><code><span class="c"># Check the circuit for errors.</span>
<span class="n">my_circuit</span><span class="o">.</span><span class="n">ERC</span><span class="p">()</span>

<span class="c"># Generate the netlist from the new Circuit object.</span>
<span class="n">my_circuit</span><span class="o">.</span><span class="n">generate_netlist</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
</code></pre>
</div>

<p>Naturally, the presence of multiple, independent circuits creates the possibility of 
new types of errors.
Here are a few things you can’t do (and will get warned about):</p>

<ul>
  <li>
    <p>You can’t make connections between parts, nets or buses that reside in 
different Circuit objects.</p>
  </li>
  <li>
    <p>Once a part, net, or bus is connected to something else in a Circuit object,
it can’t be moved to a different Circuit object.</p>
  </li>
</ul>

<h1 id="converting-existing-designs-to-skidl">Converting Existing Designs to SKiDL</h1>

<p>If you have an existing schematic-based design, you can convert it to SKiDL as follows:</p>

<ol>
  <li>
    <p>Generate a netlist file for your design using whatever procedure your ECAD
system provides. For this discussion, call the netlist file <code class="highlighter-rouge">my_design.net</code>.</p>
  </li>
  <li>
    <p>Convert the netlist file into a SKiDL program using the following command:</p>

    <div class="language-terminal highlighter-rouge"><pre class="highlight"><code> netlist_to_skidl -i my_design.net -o my_design.py -w
</code></pre>
    </div>
  </li>
</ol>

<p>That’s it! You can execute the <code class="highlighter-rouge">my_design.py</code> script and it will regenerate the
netlist. Or you can use the script as a subcircuit in a larger design.
Or do anything else that a SKiDL-based design supports.</p>

<h1 id="spice-simulations">SPICE Simulations</h1>

<p>Now you can describe a circuit using SKiDL and run a SPICE simulation on it!
Go <a href="https://github.com/xesscorp/skidl/blob/master/examples/spice-sim-intro/spice-sim-intro.ipynb">here</a>
to get the complete details.</p>

                </div>
            </article>
        </main>

        <footer class="notepad-site-footer">
    <div class="copyright">
        <section>
            <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
                <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" />
            </a>
            <br /><br />
            <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">SKiDL website</span> by 
            <a xmlns:cc="http://creativecommons.org/ns#" href="www.xess.com" property="cc:attributionName" rel="cc:attributionURL">
                XESS Corporation
            </a> 
            is licensed under a 
            <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
                Creative Commons Attribution 4.0 International License
            </a>.
        </section>
        <br />
        <p>
            <a href='http://www.catb.org/hacker-emblem/' target="_blank"><img src='https://xesscorp.github.io/skidl/docs/_site/assets/img/hacker.png' alt='hacker emblem' /></a>
            <a href="http://endsoftpatents.org/innovating-without-patents" target="_blank"><img style="border-width:0" src="https://xesscorp.github.io/skidl/docs/_site/assets/img/patent-free.png"></a>
        </p>
    </div>
    <div class="social-icons">
        
        
        <a href="http://twitter.com/xesscorp">
            <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x fa-inverse"></i>
                <i class="fa fa-twitter fa-stack-1x"></i>
            </span>
        </a>
        
        
        
        
        <a href="http://github.com/xesscorp">
            <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x fa-inverse"></i>
                <i class="fa fa-github fa-stack-1x"></i>
            </span>
        </a>
        
        
    </div>
    
    <div class="cf"></div>
</footer>

            <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="https://xesscorp.github.io/skidl/docs/_site/assets/js/vendor/jquery-1.11.1.min.js"><\/script>')</script>
    <script src="https://xesscorp.github.io/skidl/docs/_site/assets/js/vendor/modernizr.js"></script>
    <script src="https://xesscorp.github.io/skidl/docs/_site/assets/js/foundation.min.js"></script>
    
    <script src="https://xesscorp.github.io/skidl/docs/_site/assets/js/notepad.js"></script>
    <script src="https://xesscorp.github.io/skidl/docs/_site/assets/js/scripts.min.js"></script>
    <script src="https://xesscorp.github.io/skidl/docs/_site/assets/js/vendor/nprogress.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/sigma.js/1.0.3/sigma.min.js"></script>

    <script>
      $(document).foundation();
    </script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-765812-6', 'auto');
  ga('require', 'displayfeatures');
  ga('send', 'pageview');

</script>

<script>NProgress.start();var interval=setInterval(function(){NProgress.inc()},1000);jQuery(window).load(function(){clearInterval(interval);NProgress.done()});jQuery(window).unload(function(){NProgress.start()});</script>
 

    </body>
</html>